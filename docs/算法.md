## 实现使用位运算实现swap函数

```java
private void swap(int[] nums, int idx1, int idx2) {
	nums[idx1] ^= nums[idx2];
	nums[idx2] ^= nums[idx1];
	nums[idx1] ^= nums[idx2];
}
```

## 判断一个整数是否为奇数

除了常规的对2进行取余的办法进行判断，还可以采用以下的办法

```java
(i & 1) == 1
```

## 计算阶乘末尾0的个数

```java
/**
 * 解题思路：
 * 1、那么 n 过大时，从 1 遍历到 n, 那么会超时,因此我们修改下规律
 *
 *         n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) ...
 *         我们发现，
 *         每隔 5 个数就会出现 一个 5，因此我们只需要通过 n / 5 来计算存在存在多少个 5 个数，那么就对应的存在多少个 5
 *         但是，我们也会发现
 *         每隔 25 个数会出现 一个 25， 而 25 存在 两个 5，我们上面只计算了 25 的一个 5，因此我们需要 n / 25 来计算存在多少个 25，加上它遗漏的 5
 *         同时，我们还会发现
 *         每隔 125 个数会出现一个 125，而 125 存在 三个 5，我们上面只计算了 125 的两个 5，因此我们需要 n / 125 来计算存在多少个 125，加上它遗漏的 5
 *         ...
 *
 *         因此我们 count = n / 5 + n / 25 + n / 125 + ...
 *         最终分母可能过大溢出，上面的式子可以进行转换
 *
 *         count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + ...
 *         因此，我们这样进行循环
 *         n /= 5;
 *         count += n;
 *         这样，第一次加上的就是 每隔 5 个数的 5 的个数，第二次加上的就是 每隔 25 个数的 5 的个数 ...
 * @param n n
 * @return int
 */
 public int trailingZeroes(int n) {
	int count = 0;
	while (n >= 5) {
		n /= 5;
		count+=n;
	}
	return count;
}
```

## 筛选单词所有字母是否在同一行

```java
import java.util.ArrayList;
import java.util.List;

/**
 * @see <a href="https://leetcode-cn.com/problems/keyboard-row/">leetcode</a>
 */
public class Test16 {

    static String[] ss = new String[]{"qwertyuiop", "asdfghjkl", "zxcvbnm"};
    static int[] hash = new int[26];

    /**
     * 指定每个字母所在的行数
     */
    static {
        for (int i = 0; i < ss.length; i++) {
            for (char c : ss[i].toCharArray()) {
                hash[c - 'a'] = i;
            }
        }
    }
    public String[] findWords(String[] words) {
        List<String> list = new ArrayList<>();
        out:for (String w : words) {
            int t = -1;
            for (char c : w.toCharArray()) {
                c = Character.toLowerCase(c);
                if (t == -1) {
                    t = hash[c - 'a'];
                }
                else if (t != hash[c - 'a']) {
                    continue out;
                }
            }
            list.add(w);
        }
        return list.toArray(new String[list.size()]);
    }
}
```

## 寻找二叉搜索数的众数

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">leetcode</a>
 */
public class Test17 {
    // 记录上一个节点值，初始值为null是为了判断当前节点是否是第一个节点
    private Integer pre = null;
    // 二叉树中节点最大出现次数
    private int maxCount = 0;
    // 当前节点的值的最大出现次数
    private int currCount = 0;
    // 众数的个数，也就是数组长度
    private int retCount = 0;
    // 存储众数的数组
    private int[] ret = null;

    public int[] findMode(TreeNode root) {
        inOrder(root);
        pre = null;
        currCount = 0;
        ret = new int[retCount];
        retCount = 0;
        inOrder(root);
        return ret;
    }

    private void inOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        inOrder(root.left);
        // 中序遍历，搜索二叉树增序
        // 当前节点值等于前一个节点的值，这个值的出现次数+1
        if (pre != null && root.val == pre) {
            currCount++;
        } else {
            // 如果当前节点是第一个节点或者当前节点值不等于前一个节点，那么这个值的出现次数记为1
            currCount = 1;
        }
        // 如果当前值的出现次数比最大出现次数还要大，那么说明当前值才是出现最多的众数，因此数组个数记为1
        if (currCount > maxCount) {
            maxCount = currCount;
            retCount = 1;
        } else if (currCount == maxCount) {
            // 这一步是为了第二次调用时给数组赋值用的
            // 第一次调用计算得出了最大出现次数，那么第二次调用时，发现当前值的最大出现次数==第一次得出的最大出现次数，那么这个值肯定是众数之一
            if (ret != null) {
                ret[retCount] = root.val;
            }
            // 如果当前值的出现次数等于最大出现次数，那么说明有多个众数，数组个数+1
            retCount++;
        }
        // 更新pre值
        pre = root.val;
        inOrder(root.right);
    }

    static class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
  }
}
```

## 子集再求和

```java
package com.leetcode.random;

import java.util.Arrays;

/**
 * @see <a href="https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums/">leetcode</a>
 */
public class Test19 {
    public static int rangeSum(int[] nums, int n, int left, int right) {
        int mod = 1000_000_007;
        int size = n * (n + 1) / 2;
        int[] res = new int[size];
        int idx = 0;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum+=nums[j];
                res[idx++] = sum;
            }
        }
        Arrays.sort(res);
        int sum = 0;
        for (int i = left - 1; i < right; i++) {
            sum = (res[i] + sum) % mod;
        }
        return sum;
    }

    public static void main(String[] args) {
        int[] array = new int[]{1, 2, 3, 4};
        int sum = rangeSum(array, 4, 1, 5);
        System.out.println(sum);
    }
}
```

## 下一个更大元素

```java
package com.leetcode.random;

import java.util.Arrays;

/**
 * @see <a href="https://leetcode-cn.com/problems/next-greater-element-ii/submissions/">leetcode</a>
 */
public class Test18 {

    public static int[] nextGreaterElements(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];
        for (int i = 0; i < len - 1; i++) {
            res[i] = getLastNextMax(nums, len, i);
        }
        res[len - 1] = getLastNextMax(nums, len, len - 1);
        return res;
    }

    public static int getLastNextMax(int[] nums, int len, int i) {
        int end = (i + 1) % len;
        if (nums[i] < nums[end]) {
            return nums[end];
        }
        int idx = (end + 1) % len;
        while (idx != end) {
            if (nums[idx] > nums[i]) {
                return nums[idx];
            } else {
                idx = (idx + 1) % len;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] array = new int[]{1,2,1};
        int[] greaterElements = nextGreaterElements(array);
        System.out.println(Arrays.toString(greaterElements));
    }
}
```

