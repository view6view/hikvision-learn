# 思路

## 实现使用位运算实现swap函数

```java
private void swap(int[] nums, int idx1, int idx2) {
	nums[idx1] ^= nums[idx2];
	nums[idx2] ^= nums[idx1];
	nums[idx1] ^= nums[idx2];
}
```

## 判断一个整数是否为奇数

除了常规的对2进行取余的办法进行判断，还可以采用以下的办法

```java
(i & 1) == 1
```

## 计算阶乘末尾0的个数

```java
/**
 * 解题思路：
 * 1、那么 n 过大时，从 1 遍历到 n, 那么会超时,因此我们修改下规律
 *
 *         n! = 1 * 2 * 3 * 4 * (1 * 5) * ... * (2 * 5) * ... * (3 * 5) ...
 *         我们发现，
 *         每隔 5 个数就会出现 一个 5，因此我们只需要通过 n / 5 来计算存在存在多少个 5 个数，那么就对应的存在多少个 5
 *         但是，我们也会发现
 *         每隔 25 个数会出现 一个 25， 而 25 存在 两个 5，我们上面只计算了 25 的一个 5，因此我们需要 n / 25 来计算存在多少个 25，加上它遗漏的 5
 *         同时，我们还会发现
 *         每隔 125 个数会出现一个 125，而 125 存在 三个 5，我们上面只计算了 125 的两个 5，因此我们需要 n / 125 来计算存在多少个 125，加上它遗漏的 5
 *         ...
 *
 *         因此我们 count = n / 5 + n / 25 + n / 125 + ...
 *         最终分母可能过大溢出，上面的式子可以进行转换
 *
 *         count = n / 5 + n / 5 / 5 + n / 5 / 5 / 5 + ...
 *         因此，我们这样进行循环
 *         n /= 5;
 *         count += n;
 *         这样，第一次加上的就是 每隔 5 个数的 5 的个数，第二次加上的就是 每隔 25 个数的 5 的个数 ...
 * @param n n
 * @return int
 */
 public int trailingZeroes(int n) {
	int count = 0;
	while (n >= 5) {
		n /= 5;
		count+=n;
	}
	return count;
}
```

# Leetcode随机

## 筛选单词所有字母是否在同一行

```java
import java.util.ArrayList;
import java.util.List;

/**
 * @see <a href="https://leetcode-cn.com/problems/keyboard-row/">leetcode</a>
 */
public class Test16 {

    static String[] ss = new String[]{"qwertyuiop", "asdfghjkl", "zxcvbnm"};
    static int[] hash = new int[26];

    /**
     * 指定每个字母所在的行数
     */
    static {
        for (int i = 0; i < ss.length; i++) {
            for (char c : ss[i].toCharArray()) {
                hash[c - 'a'] = i;
            }
        }
    }
    public String[] findWords(String[] words) {
        List<String> list = new ArrayList<>();
        out:for (String w : words) {
            int t = -1;
            for (char c : w.toCharArray()) {
                c = Character.toLowerCase(c);
                if (t == -1) {
                    t = hash[c - 'a'];
                }
                else if (t != hash[c - 'a']) {
                    continue out;
                }
            }
            list.add(w);
        }
        return list.toArray(new String[list.size()]);
    }
}
```

## 寻找二叉搜索数的众数

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/">leetcode</a>
 */
public class Test17 {
    // 记录上一个节点值，初始值为null是为了判断当前节点是否是第一个节点
    private Integer pre = null;
    // 二叉树中节点最大出现次数
    private int maxCount = 0;
    // 当前节点的值的最大出现次数
    private int currCount = 0;
    // 众数的个数，也就是数组长度
    private int retCount = 0;
    // 存储众数的数组
    private int[] ret = null;

    public int[] findMode(TreeNode root) {
        inOrder(root);
        pre = null;
        currCount = 0;
        ret = new int[retCount];
        retCount = 0;
        inOrder(root);
        return ret;
    }

    private void inOrder(TreeNode root) {
        if (root == null) {
            return;
        }
        inOrder(root.left);
        // 中序遍历，搜索二叉树增序
        // 当前节点值等于前一个节点的值，这个值的出现次数+1
        if (pre != null && root.val == pre) {
            currCount++;
        } else {
            // 如果当前节点是第一个节点或者当前节点值不等于前一个节点，那么这个值的出现次数记为1
            currCount = 1;
        }
        // 如果当前值的出现次数比最大出现次数还要大，那么说明当前值才是出现最多的众数，因此数组个数记为1
        if (currCount > maxCount) {
            maxCount = currCount;
            retCount = 1;
        } else if (currCount == maxCount) {
            // 这一步是为了第二次调用时给数组赋值用的
            // 第一次调用计算得出了最大出现次数，那么第二次调用时，发现当前值的最大出现次数==第一次得出的最大出现次数，那么这个值肯定是众数之一
            if (ret != null) {
                ret[retCount] = root.val;
            }
            // 如果当前值的出现次数等于最大出现次数，那么说明有多个众数，数组个数+1
            retCount++;
        }
        // 更新pre值
        pre = root.val;
        inOrder(root.right);
    }

    static class TreeNode {
      int val;
      TreeNode left;
      TreeNode right;
      TreeNode() {}
      TreeNode(int val) { this.val = val; }
      TreeNode(int val, TreeNode left, TreeNode right) {
          this.val = val;
          this.left = left;
          this.right = right;
      }
  }
}
```

## 子集再求和

```java
import java.util.Arrays;

/**
 * @see <a href="https://leetcode-cn.com/problems/range-sum-of-sorted-subarray-sums/">leetcode</a>
 */
public class Test19 {
    public static int rangeSum(int[] nums, int n, int left, int right) {
        int mod = 1000_000_007;
        int size = n * (n + 1) / 2;
        int[] res = new int[size];
        int idx = 0;
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum+=nums[j];
                res[idx++] = sum;
            }
        }
        Arrays.sort(res);
        int sum = 0;
        for (int i = left - 1; i < right; i++) {
            sum = (res[i] + sum) % mod;
        }
        return sum;
    }

    public static void main(String[] args) {
        int[] array = new int[]{1, 2, 3, 4};
        int sum = rangeSum(array, 4, 1, 5);
        System.out.println(sum);
    }
}
```

## 下一个更大元素

```java
import java.util.Arrays;

/**
 * @see <a href="https://leetcode-cn.com/problems/next-greater-element-ii/submissions/">leetcode</a>
 */
public class Test18 {

    public static int[] nextGreaterElements(int[] nums) {
        int len = nums.length;
        int[] res = new int[len];
        for (int i = 0; i < len - 1; i++) {
            res[i] = getLastNextMax(nums, len, i);
        }
        res[len - 1] = getLastNextMax(nums, len, len - 1);
        return res;
    }

    public static int getLastNextMax(int[] nums, int len, int i) {
        int end = (i + 1) % len;
        if (nums[i] < nums[end]) {
            return nums[end];
        }
        int idx = (end + 1) % len;
        while (idx != end) {
            if (nums[idx] > nums[i]) {
                return nums[idx];
            } else {
                idx = (idx + 1) % len;
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        int[] array = new int[]{1,2,1};
        int[] greaterElements = nextGreaterElements(array);
        System.out.println(Arrays.toString(greaterElements));
    }
}
```

## 三次操作后最大值与最小值的最小差

```java
import java.util.Arrays;

/**
 * @see <a href="https://leetcode-cn.com/problems/minimum-difference-between-largest-and-smallest-value-in-three-moves/">leetcode</a>
 */
public class Test21 {
    public static void main(String[] args) {
        int[] arr = new int[]{6,6,0,1,1,4,6};
        System.out.println(minDifference(arr));
    }

    public static int minDifference(int[] nums) {
        if(nums.length <= 4) {
            return 0;
        }
        Arrays.sort(nums);
        int maxValue = Integer.MAX_VALUE;
        if(nums[nums.length - 1] - nums[3] < maxValue) {
            maxValue = nums[nums.length - 1] - nums[3];
        }
        if(nums[nums.length - 2] - nums[2] < maxValue) {
            maxValue = nums[nums.length - 2] - nums[2];
        }
        if(nums[nums.length - 3] - nums[1] < maxValue) {
            maxValue = nums[nums.length - 3] - nums[1];
        }
        if(nums[nums.length - 4] - nums[0] < maxValue) {
            maxValue = nums[nums.length - 4] - nums[0];
        }

        return maxValue;
    }

//    public static int minDifference(int[] nums) {
//        int len = nums.length;
//        if (len <= 4) {
//            return 0;
//        }
//        int distinctCount = insertSort(nums);
//        if (distinctCount == len || distinctCount > 5) {
//            return Math.min(nums[len - 1] - nums[3], nums[len - 4] - nums[0]);
//        }
//        int min = Integer.MAX_VALUE;
//        for (int i = 0; i < 4; i++) {
//            min = Math.min(min, nums[i + 1] - nums[i]);
//        }
//        return min;
//    }
//
//    public static int insertSort(int[] nums) {
//        int count = 0;
//        int len = nums.length;
//        for (int i = 0; i < len; i++) {
//            int temp = nums[i];
//            int idx = i - 1;
//            while (idx >= 0) {
//                 if (nums[idx] > temp){
//                    nums[idx + 1] = nums[idx];
//                    idx--;
//                } else {
//                     if (nums[idx] == temp) {
//                         count++;
//                     }
//                     break;
//                 }
//            }
//            idx++;
//            nums[idx] = temp;
//        }
//        return len - count;
//    }
}
```

## 好数对的数目

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/number-of-good-pairs/">leetcode</a>
 */
public class Test22 {
    public int numIdenticalPairs(int[] nums) {
        int ans = 0;
        //因为 1<= nums[i] <= 100  所以申请大小为100的数组
        //temp用来记录num的个数
        int[] temp = new int[100];
        for (int num : nums) {
            /*
            这行代码可以写成
            ans+=temp[num - 1];
            temp[num - 1]++;
            */
            ans += temp[num - 1]++;
        }
        return ans;
    }
}
```

## 仅含 1 的子串数

```java
import java.util.LinkedList;
import java.util.List;

/**
 * @see <a href="https://leetcode-cn.com/problems/number-of-substrings-with-only-1s/">leetcode</a>
 */
public class Test23 {
    public static int numSub(String s) {
        int mod = 1000_000_007;
        char[] arr = s.toCharArray();
        int len = arr.length;
        List<Integer> list = new LinkedList<>();
        for (int i = 0; i < len; i++) {
            if (arr[i] == '1') {
                int count = 1;
                while (i < len - 1 && arr[++i] == '1') {
                    count++;
                }
                list.add(count);
            }
        }
        int res = 0;
        for(int num : list) {
            while (num != 0) {
                res = (res + num) % mod;
                num--;
            }
        }
        return res;
    }

    public static void main(String[] args) {
        System.out.println(numSub("0110111"));
    }
}
```

## 换酒问题

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/water-bottles/">leetcode</a>
 */
public class Test24 {
    public int numWaterBottles(int numBottles, int numExchange) {
        // 余数
        int remainder;
        // 除数
        int divisor;
        // 空瓶子数
        int empty =  numBottles;
        // 喝酒数
        int count = numBottles;
        while (empty >= numExchange) {
            remainder = empty % numExchange;
            divisor = empty / numExchange;
            count+=divisor;
            empty = remainder + divisor;
        }
        return count;
    }
}
```

## 奇数个数

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/count-odd-numbers-in-an-interval-range/">leetcode</a>
 */
public class Test25 {
    public int countOdds(int low, int high) {
        if (low == high) {
            return low & 1;
        }
        return (low & 1) == 1 || (high & 1) == 1 ? (high - low) / 2 + 1 : (high - low) / 2;
    }
}
```

## 和为奇数的子数组数目

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/number-of-sub-arrays-with-odd-sum/submissions/">leetcode</a>
 */
public class Test26 {
    public int numOfSubarrays(int[] arr) {
        int mod  = 1000_000_007;
        // 奇数数字个数
        int oddCount = 0;
        // 偶数数字个数
        int evenCount = 0;
        int count = 0;
        for (int num : arr) {
            if ((num & 1) == 1) {
                int temp = oddCount;
                oddCount = evenCount + 1;
                evenCount = temp;
            } else {
                evenCount++;
            }
            count = (count + oddCount) % mod;
        }
        return count;
    }
}
```

## 字符串的好分割数目

```java
import java.util.HashSet;
import java.util.Set;

/**
 * @see <a href="https://leetcode-cn.com/problems/number-of-good-ways-to-split-a-string/">leetcode</a>
 */
public class Test27 {
    public int numSplits(String s) {
        char[] chars = s.toCharArray();
        int len = chars.length;
        int[] left = new int[len];
        int[] right = new int[len];
        Set<Character> leftSet = new HashSet<>();
        Set<Character> rightSet = new HashSet<>();
        for (int i = 0, j = len - 1; i < len; i++, j --) {
            if (!leftSet.contains(chars[i])) {
                leftSet.add(chars[i]);
            }
            left[i] = leftSet.size();
            if (!rightSet.contains(chars[j])) {
                rightSet.add(chars[j]);
            }
            right[j] = rightSet.size();
        }
        int count = 0;
        for (int i = 0; i < len - 1; i++) {
            if (left[i] == right[i + 1]) {
                count++;
            }
        }
        return count;
    }
}
```

## 形成目标数组的子数组最少增加次数

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/">leetcode</a>
 */
public class Test28 {
    public int minNumberOperations(int[] target) {
        if (target == null || target.length == 0) return 0;

        int ans = target[0];
        for (int i = 1; i < target.length; i++) {
            // 若target[i] - target[i - 1] > 0
            ans += Math.max(target[i] - target[i - 1], 0);
        }

        return ans;
    }
}
```

## 重新排列字符串

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/shuffle-string/">leetcode</a>
 */
public class Test29 {
    public static String restoreString(String s, int[] indices) {
        char[] res = new char[indices.length];
        for (int i = 0; i < indices.length; i++) {
            res[indices[i]] = s.charAt(i);
        }
        return  String.valueOf(res);
    }

    public static void main(String[] args) {
        int[] arr = new int[]{4,5,6,7,0,2,1,3};
        System.out.println(restoreString("codeleet", arr));
    }
}
```

## 最少的后缀翻转次数

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/minimum-suffix-flips/">leetcode</a>
 */
public class Test30 {
    public int minFlips(String target) {
        char[] chars = target.toCharArray();
        int len = chars.length;
        // 翻转次数
        int count = 0;
        int idx = 0;
        // 找到第一个 1 出现的位置
        for (int i = 0; i < len; i++) {
            if (chars[i] == '0') {
                continue;
            } else {
                count = 1;
                idx = i;
                break;
            }
        }
        if (count == 0) {
            return 0;
        }
        char pre = chars[idx];
        // 遍历 idx 之后的元素
        for (int i = idx + 1; i < len; i++) {
            char c = chars[i];
            if (c != pre) {
                count++;
                // 更新 pre
                pre = c;
            }
        }
        return count;
    }
}
```

## 统计好三元组

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/count-good-triplets/">leetcode</a>
 */
public class Test33 {
    public int countGoodTriplets(int[] arr, int a, int b, int c) {
        int len = arr.length;
        int count = 0;
        for(int i=0;i<len;i++){
            for(int j=i+1;j<len;++j){
                for(int k=j+1;k<len;k++){
                    if(Math.abs(arr[i]-arr[j])<=a && Math.abs(arr[k]-arr[j])<=b && Math.abs(arr[i]-arr[k])<=c) {
                        count ++;
                    }
                }
            }
        }
        return count;
    }
}
```

## 找出数组游戏的赢家

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/find-the-winner-of-an-array-game/">leetcode</a>
 */
public class Test34 {
    public static void main(String[] args) {
        int[] arr = new int[]{2,1,3,5,4,6,7};
        System.out.println(getWinner1(arr, 2));
    }

    /**
     * 超出时间限制
     * @param arr
     * @param k
     * @return
     */
    public static int getWinner1(int[] arr, int k) {
        // 连胜回合数
        int circle = 0;
        int pre = -1;
        int endIdx = arr.length - 1;
        int temp;
        while (true) {
            if (arr[0] > arr[1]) {
                if (circle == 0) {
                    circle++;
                    pre = arr[0];
                } else {
                    if (arr[0] == pre) {
                        circle++;
                        if (circle >= k) {
                            break;
                        }
                    } else {
                        circle = 1;
                        pre = arr[0];
                    }
                }
                temp = arr[1];
                for (int i = 1; i < endIdx; i++) {
                    arr[i] = arr[i + 1];
                }
            } else {
                if (circle == 0) {
                    circle++;
                    pre = arr[1];
                } else {
                    if (arr[1] == pre) {
                        circle++;
                        if (circle >= k) {
                            break;
                        }
                    } else {
                        circle = 1;
                        pre = arr[1];
                    }
                }
                temp = arr[0];
                for (int i = 0; i < endIdx; i++) {
                    arr[i] = arr[i + 1];
                }
            }
            arr[endIdx] = temp;
        }
        return arr[0];
    }

    public int getWinner(int[] arr, int k) {
        // win:胜利者,count:获胜场次
        int win=arr[0], count=0;
        /*到达获胜场次跳出循环*/
        for(int i = 1; i < arr.length && count < k; i++){
            /*arr[i]比win小*的情况*/
            if(arr[i] < win){
                count++;
            } else {
                /*如果win输掉了产生新的胜利者，count置为1*/
                win=arr[i];
                count=1;
            }
        }
        /*返回win*/
        return win;
    }
}
```

## 第 k 个缺失的正整数

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/kth-missing-positive-number/">leetcode</a>
 */
public class Test35 {
    public static void main(String[] args) {
        int[] arr = new int[]{1,2};
        System.out.println(findKthPositive(arr, 1));
    }

    public static int findKthPositive(int[] arr, int k) {
        int lackCount = 0;
        int num = 0;
        int idx = 0;
        while (lackCount != k && idx < arr.length) {
            num++;
            if (arr[idx] == num) {
                idx++;
            } else {
                lackCount++;
            }
        }
        if (lackCount != k) {
            while (lackCount < k) {
                num++;
                lackCount++;
            }
        }
        return num;
    }
}
```

## K 次操作转变字符串

```java
/**
 * @see <a href="https://leetcode-cn.com/problems/can-convert-string-in-k-moves/">leetcode</a>
 */
public class Test36 {
    public static void main(String[] args) {
        String s1 = "atmtxzjkz";
        String s2 = "tvbtjhvjd";
        for (int i = 0; i < s1.length(); i++) {
            System.out.println(Math.abs(s1.charAt(i) - s2.charAt(i)));
        }
        System.out.println(canConvertString(s1, s2, 35));
    }

    public static boolean canConvertString(String s, String t, int k) {
        if (s.length() != t.length()) {
            return false;
        }
        int len = s.length();
        int[] arr = new int[26];
        for (int i = 0; i < len; i++) {
            // 需要走的距离，范围为[0,25]
            int distance = (t.charAt(i) - s.charAt(i) + 26) % 26;
            if (distance != 0) {
                // 实际需要走的距离，因为之前可能已经走过这次了，需要多走 arr[distance] 圈
                int realDistance = distance + arr[distance] * 26;
                if (realDistance <= k) {
                    arr[distance]++;
                } else {
                    return false;
                }
            }
        }
        return true;
    }
}
```

